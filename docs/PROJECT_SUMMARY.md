# Graph Colouring Benchmark Suite - Project Summary

## Overview

This is an **Advanced Algorithm Design (AAD)** coursework project that implements and benchmarks various graph colouring algorithms. Graph colouring is an NP-hard problem where the goal is to assign colours to vertices such that no two adjacent vertices share the same colour, using as few colours as possible (the **chromatic number**).

---

## Project Structure

| Directory | Purpose |
|-----------|---------|
| `src/` | C++ source code |
| `src/algorithms/` | Graph colouring algorithm implementations |
| `src/io/` | Graph loading, colouring output, and CSV result logging |
| `scripts/` | Python utilities for benchmarking, graph generation, and animation |
| `scripts/datasets/` | DIMACS and generated graph files with metadata |
| `results/` | Output colourings and CSV benchmark results |
| `snapshots-colouring/` | Step-by-step algorithm state snapshots for visualization |
| `info/` | Documentation and citations |

---

## Implemented Algorithms

| Algorithm | Type | Description |
|-----------|------|-------------|
| **Welsh-Powell** | Greedy heuristic | Orders vertices by degree, assigns lowest available colour |
| **DSatur** | Greedy heuristic | Prioritizes vertices with most distinct neighbour colours (saturation) |
| **Simulated Annealing** | Metaheuristic | Temperature-based probabilistic acceptance of worse solutions |
| **Genetic Algorithm** | Evolutionary | Population-based with crossover, mutation, and selection |
| **Exact Solver** | Branch-and-bound | Guarantees optimal chromatic number |
| **Tabu Search** | Metaheuristic | TabuCol algorithm - iterative conflict repair with memory-based cycle prevention |

### Tabu Search (TabuCol) - Details

The **Tabu Search** algorithm is an industry-standard metaheuristic for graph colouring that was added to address the performance limitations of the Genetic Algorithm.

**Strategy:**
1. Start with a random k-colouring (may have conflicts)
2. Iteratively select a conflicting vertex and move it to the colour that minimizes conflicts
3. Mark the move (vertex, old_colour) as "tabu" for a tenure period to prevent cycling back
4. Accept the best non-tabu move; allow tabu moves only if they achieve a new global best (aspiration criterion)
5. If zero conflicts achieved, decrease k and restart
6. Stop when no feasible k-colouring found within iteration limit

**Key Parameters:**
- `max_iterations`: Maximum iterations per k value (default: 10000 or 100×|V|)
- `tabu_tenure`: Number of iterations a move stays forbidden (default: 7 or |V|/10)

**Why TabuCol over Genetic Algorithm:**
- More efficient: avoids expensive population management
- Better escape from local optima via tabu list memory
- Industry-proven for graph colouring benchmarks
- Faster convergence on hard instances

---

## Datasets

### DIMACS Benchmarks (`scripts/datasets/dimacs/`)
- **81 standard graphs** from the DIMACS graph colouring challenge
- Types: queen graphs, mycielski, flat, DSJ random, register allocation, school scheduling
- Metadata in `metadata-dimacs.csv`

### Generated Graphs (`scripts/datasets/generated/`)
- **55 synthetic graphs** created using NetworkX
- Types: bipartite, planar, tree, grid, Erdős-Rényi, Barabási-Albert (scale-free), Watts-Strogatz (small-world)
- Metadata in `metadata-generated.csv`

### Simple Tests (`scripts/datasets/simple-tests/`)
- 3 small test graphs: `cycle10.col`, `k-12.col` (complete K₁₂), `k-12plus.col`

---

## Input/Output Formats

### Input (DIMACS `.col` format)
```
c Comments
p edge 11 20          # 11 vertices, 20 edges
e 1 2                 # Edge from vertex 1 to 2
e 1 4
...
```

### Colouring Output
```
c colouring generated by benchmark framework
p edge 11 20
v 1 1                 # Vertex 1 has colour 1
v 2 0                 # Vertex 2 has colour 0
...
```

### Results CSV
```csv
algorithm,graph_name,vertices,edges,colors_used,known_optimal,runtime_ms,status
dsatur,myciel6,95,755,7,7,0.135,ok
```

---

## Snapshots for Visualization

The `snapshots-colouring/` directory contains **57 snapshot files** named `<algorithm>-<graph>-snnapshots.txt`.

**Format**: Each line is a space-separated colour vector:
- `-1` = uncoloured vertex
- `0, 1, 2, ...` = assigned colour

**Example** (`dsatur-myciel3-snnapshots.txt`):
```
-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 0    # Step 1: vertex 10 gets colour 0
-1 -1 -1 -1 -1 1 -1 -1 -1 -1 0     # Step 2: vertex 5 gets colour 1
...
1 0 1 2 0 1 2 1 2 3 0              # Final colouring
```

Used by `scripts/animate_coloring.py` to visualize algorithm progression.

---

## Results & Analysis

### Output Files (`results/`)

| File | Description |
|------|-------------|
| `results.csv` | Ad-hoc single runs |
| `run_all_results.csv` | Batch benchmark results (319 rows) with timeout status |
| `graph_family_best_analysis.csv` | Per-family performance analysis |
| `family_graphs.py` | Aggregation script for family-level analysis |
| `colourings/` | ~330 colouring output files |

### Performance Insights

| Graph Family | Best Algorithm | Avg Ratio (colors/optimal) |
|--------------|----------------|---------------------------|
| anna, david, games, homer, huck, jean | All (tie) | 1.0 (optimal) |
| fpsol, inithx, miles | DSatur | 1.0 (optimal) |
| DSJC | DSatur | 1.29 |
| DSJR | Genetic | 1.02 |
| flat | Genetic | 1.78 |
| le (Leighton) | DSatur | 1.46 |

---

## How to Use

### Build
```bash
make all
# Output: build/benchmark_runner
```

### Run Single Algorithm
```bash
make run-dsatur GRAPH=dimacs/myciel6.col
make run-genetic GRAPH=dimacs/myciel6.col
make run-exact GRAPH=dimacs/myciel6.col
```

### Run All Benchmarks
```bash
make run-all-benchmarking
# Runs all algorithms on all graphs with timeouts (15s first pass, 30s retry)
# Output: results/run_all_results.csv
```

### Animate Colouring
```bash
python3 scripts/animate_coloring.py --graph myciel6 --algo dsatur
python3 scripts/animate_coloring.py --graph myciel6 --algo tabu_search
python3 scripts/animate_coloring.py --graph myciel6 --all-algos
```

---

## Key Scripts

| Script | Purpose |
|--------|---------|
| `run_all_benchmarks.py` | Orchestrates batch runs with timeouts |
| `generate_graphs.py` | Generates synthetic graphs using NetworkX |
| `animate_coloring.py` | Visualizes colouring progression from snapshots |
| `family_graphs.py` | Aggregates results by graph family |

---

## Technical Details

- **Language**: C++20 with Python 3.8+ for orchestration
- **Build**: Makefile-based
- **Graph Representation**: Adjacency list (`std::vector<std::vector<int>>`)
- **Timing**: `std::chrono::high_resolution_clock`

---

## Algorithm Performance Notes

### Most Disappointing: Genetic Algorithm
The Genetic Algorithm was computationally expensive (taking up to 86 seconds for DSJC1000.5) without providing better solutions than DSatur. In some cases, it even timed out or produced worse results.

### Recommended Alternative: Tabu Search (TabuCol)
Tabu Search was implemented as a replacement for the underperforming Genetic/SA algorithms. It is the industry standard metaheuristic for graph colouring due to:
- **Efficiency**: No expensive population management
- **Effectiveness**: Memory-based escape from local optima
- **Proven track record**: Standard choice in DIMACS benchmarks

---

## Future Work

- [x] ~~Implement Tabu Search algorithm~~ (Completed)
- [ ] Benchmark Tabu Search against other algorithms
- [ ] Add more graph families to benchmarks
- [ ] Fine-tune Tabu Search parameters (tenure, iterations)
- [ ] Add parallel execution support
- [ ] Consider hybrid approaches (e.g., Tabu + SA)
